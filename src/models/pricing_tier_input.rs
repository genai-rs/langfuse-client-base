/*
 * langfuse
 *
 * ## Authentication  Authenticate with the API using [Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication), get API keys in the project settings:  - username: Langfuse Public Key - password: Langfuse Secret Key  ## Exports  - OpenAPI spec: https://cloud.langfuse.com/generated/api/openapi.yml - Postman collection: https://cloud.langfuse.com/generated/postman/collection.json
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// PricingTierInput : Input schema for creating a pricing tier. The tier ID will be automatically generated server-side.  When creating a model with pricing tiers: - Exactly one tier must have isDefault=true (the fallback tier) - The default tier must have priority=0 and conditions=[] - All tier names and priorities must be unique within the model - Each tier must define at least one price  See PricingTier for detailed information about how tiers work and why they're useful.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize, bon::Builder)]
pub struct PricingTierInput {
    /// Name of the pricing tier for display and identification purposes.  Must be unique within the model. Common patterns: \"Standard Pricing\", \"High Volume Tier\", \"Extended Context\"
    #[serde(rename = "name")]
    pub name: String,
    /// Whether this is the default tier. Exactly one tier per model must be marked as default.  Requirements for default tier: - Must have isDefault=true - Must have priority=0 - Must have empty conditions array (conditions=[])  The default tier acts as a fallback when no conditional tiers match.
    #[serde(rename = "isDefault")]
    pub is_default: bool,
    /// Priority for tier matching evaluation. Lower numbers = higher priority (evaluated first).  Must be unique within the model. The default tier must have priority=0. Conditional tiers should use priority 1, 2, 3, etc. based on their specificity.
    #[serde(rename = "priority")]
    pub priority: i32,
    /// Array of conditions that must ALL be met for this tier to match (AND logic).  The default tier must have an empty array (conditions=[]). Conditional tiers should define one or more conditions that specify when this tier's pricing applies.  Each condition specifies a regex pattern, operator, and threshold value for matching against usage details.
    #[serde(rename = "conditions")]
    pub conditions: Vec<models::PricingTierCondition>,
    /// Prices (USD) by usage type for this tier. At least one price must be defined.  Common usage types: \"input\", \"output\", \"total\", \"request\", \"image\" Prices are in USD per unit (e.g., per token).  Example: {\"input\": 0.000003, \"output\": 0.000015} represents $3 per million input tokens and $15 per million output tokens.
    #[serde(rename = "prices")]
    pub prices: std::collections::HashMap<String, f64>,
}

impl PricingTierInput {
    /// Input schema for creating a pricing tier. The tier ID will be automatically generated server-side.  When creating a model with pricing tiers: - Exactly one tier must have isDefault=true (the fallback tier) - The default tier must have priority=0 and conditions=[] - All tier names and priorities must be unique within the model - Each tier must define at least one price  See PricingTier for detailed information about how tiers work and why they're useful.
    pub fn new(
        name: String,
        is_default: bool,
        priority: i32,
        conditions: Vec<models::PricingTierCondition>,
        prices: std::collections::HashMap<String, f64>,
    ) -> PricingTierInput {
        PricingTierInput {
            name,
            is_default,
            priority,
            conditions,
            prices,
        }
    }
}
