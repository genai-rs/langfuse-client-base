/*
 * langfuse
 *
 * ## Authentication  Authenticate with the API using [Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication), get API keys in the project settings:  - username: Langfuse Public Key - password: Langfuse Secret Key  ## Exports  - OpenAPI spec: https://cloud.langfuse.com/generated/api/openapi.yml - Postman collection: https://cloud.langfuse.com/generated/postman/collection.json
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// PricingTier : Pricing tier definition with conditional pricing based on usage thresholds.  Pricing tiers enable accurate cost tracking for LLM providers that charge different rates based on usage patterns. For example, some providers charge higher rates when context size exceeds certain thresholds.  How tier matching works: 1. Tiers are evaluated in ascending priority order (priority 1 before priority 2, etc.) 2. The first tier where ALL conditions match is selected 3. If no conditional tiers match, the default tier is used as a fallback 4. The default tier has priority 0 and no conditions  Why priorities matter: - Lower priority numbers are evaluated first, allowing you to define specific cases before general ones - Example: Priority 1 for \"high usage\" (>200K tokens), Priority 2 for \"medium usage\" (>100K tokens), Priority 0 for default - Without proper ordering, a less specific condition might match before a more specific one  Every model must have exactly one default tier to ensure cost calculation always succeeds.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize, bon::Builder)]
pub struct PricingTier {
    /// Unique identifier for the pricing tier
    #[serde(rename = "id")]
    pub id: String,
    /// Name of the pricing tier for display and identification purposes.  Examples: \"Standard\", \"High Volume Tier\", \"Large Context\", \"Extended Context Tier\"
    #[serde(rename = "name")]
    pub name: String,
    /// Whether this is the default tier. Every model must have exactly one default tier with priority 0 and no conditions.  The default tier serves as a fallback when no conditional tiers match, ensuring cost calculation always succeeds. It typically represents the base pricing for standard usage patterns.
    #[serde(rename = "isDefault")]
    pub is_default: bool,
    /// Priority for tier matching evaluation. Lower numbers = higher priority (evaluated first).  The default tier must always have priority 0. Conditional tiers should have priority 1, 2, 3, etc.  Example ordering: - Priority 0: Default tier (no conditions, always matches as fallback) - Priority 1: High usage tier (e.g., >200K tokens) - Priority 2: Medium usage tier (e.g., >100K tokens)  This ensures more specific conditions are checked before general ones.
    #[serde(rename = "priority")]
    pub priority: i32,
    /// Array of conditions that must ALL be met for this tier to match (AND logic).  The default tier must have an empty conditions array. Conditional tiers should have one or more conditions that define when this tier's pricing applies.  Multiple conditions enable complex matching scenarios (e.g., \"high input tokens AND low output tokens\").
    #[serde(rename = "conditions")]
    pub conditions: Vec<models::PricingTierCondition>,
    /// Prices (USD) by usage type for this tier.  Common usage types: \"input\", \"output\", \"total\", \"request\", \"image\" Prices are specified in USD per unit (e.g., per token, per request, per second).  Example: {\"input\": 0.000003, \"output\": 0.000015} means $3 per million input tokens and $15 per million output tokens.
    #[serde(rename = "prices")]
    pub prices: std::collections::HashMap<String, f64>,
}

impl PricingTier {
    /// Pricing tier definition with conditional pricing based on usage thresholds.  Pricing tiers enable accurate cost tracking for LLM providers that charge different rates based on usage patterns. For example, some providers charge higher rates when context size exceeds certain thresholds.  How tier matching works: 1. Tiers are evaluated in ascending priority order (priority 1 before priority 2, etc.) 2. The first tier where ALL conditions match is selected 3. If no conditional tiers match, the default tier is used as a fallback 4. The default tier has priority 0 and no conditions  Why priorities matter: - Lower priority numbers are evaluated first, allowing you to define specific cases before general ones - Example: Priority 1 for \"high usage\" (>200K tokens), Priority 2 for \"medium usage\" (>100K tokens), Priority 0 for default - Without proper ordering, a less specific condition might match before a more specific one  Every model must have exactly one default tier to ensure cost calculation always succeeds.
    pub fn new(
        id: String,
        name: String,
        is_default: bool,
        priority: i32,
        conditions: Vec<models::PricingTierCondition>,
        prices: std::collections::HashMap<String, f64>,
    ) -> PricingTier {
        PricingTier {
            id,
            name,
            is_default,
            priority,
            conditions,
            prices,
        }
    }
}
